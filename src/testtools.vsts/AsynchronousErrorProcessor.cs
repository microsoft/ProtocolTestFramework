// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Protocols.TestTools.Checking;
using System.Reflection;
using System.Diagnostics;
using System.Threading;

namespace Microsoft.Protocols.TestTools
{
    /// <summary>
    /// This is the implementation of AsynchronousErrorProcessor for processing errors occurred in non-main thread.
    /// </summary>
    internal class AsynchronousErrorProcessor
    {
        /// <summary>
        /// ErrorDescriptor contains the exception generated by checkers and the call stack string.
        /// </summary>
        private struct ErrorDescriptor
        {
            public readonly Exception exception;
            public readonly string stackTraceString;

            public ErrorDescriptor(Exception exception, 
                                string stackTraceString)
            {
                this.exception = exception;
                this.stackTraceString = stackTraceString;
            }
        }

        // Private member that is used for locking ReportAsyncException().
        private readonly object reportAsyncExceptionLock = new object();

        // Private member that is used for locking Process().
        private readonly object processLock = new object();

        // Private memeber that is for buffering the errors reported by checkers.
        private static List<ErrorDescriptor> errors = new List<ErrorDescriptor>();

        private static List<ErrorDescriptor> assertFailErrors = new List<ErrorDescriptor>();

        private static bool shouldThrowAssertFailException;

        // Private memeber that is for storing the reference to the main thread.
        private Thread mainThread;

        private int assertFailuresBeforeThrowException;

        private int maxFailuresToDisplayPerTestCase;

        /// <summary>
        /// Initializes a new instance of AsynchronousErrorProcessor
        /// </summary>
        /// <param name="assertFailuresBeforeThrowException">The number of assert fail can be bypassed.</param>
        /// <param name="maxFailuresToDisplayPerTestCase">The maxNumber of failure messages displayed.</param>
        public AsynchronousErrorProcessor(int assertFailuresBeforeThrowException, int maxFailuresToDisplayPerTestCase)
        {
            // The thread in which the AsynchronousErrorProcessor is created 
            // will be set as the main thread by default.
            mainThread = Thread.CurrentThread;
            this.assertFailuresBeforeThrowException = assertFailuresBeforeThrowException;
            this.maxFailuresToDisplayPerTestCase = maxFailuresToDisplayPerTestCase;
        }

        /// <summary>
        /// Sets the current thread as main thread and clean the error list.
        /// </summary>
        public void Initialize()
        {
            mainThread = Thread.CurrentThread;

            // Must clean the error list before each test.
            errors.Clear();
            assertFailErrors.Clear();
        }

        /// <summary>
        /// Process the pending errors in error list.
        /// </summary>
        public void Cleanup()
        {
            Process();
            if (shouldThrowAssertFailException)
            {
                string message = GenerateBypassedErrorMessage();
                shouldThrowAssertFailException = false;
                if (!string.IsNullOrEmpty(message))
                {
                    throw new AssertFailedException(message);
                }
            }
        }

        private string GenerateBypassedErrorMessage()
        { 
            string message = string.Empty;
            if (errors.Count > 0)
            {
                message += String.Format("{0}\r\n"
                                                + "===== Stack Trace =====\r\n"
                                                + "{1}"
                                                + "=== End of Stack Trace ===\r\n",
                                                errors[0].exception.Message,
                                                errors[0].stackTraceString);
            }
            if (assertFailErrors.Count > 0)
            {
                int count = 0;
                message += string.Format("There are {0} assert fail bypassed in this test case:\r\n", assertFailErrors.Count);
                foreach (ErrorDescriptor assert in assertFailErrors)
                {
                    if (count >= this.maxFailuresToDisplayPerTestCase)
                    {
                        message += "... ...";
                        break;
                    }
                    message += String.Format("\r\n===== Assert Fail {0} ====\r\n"
                        + "{1}\r\n"
                        + "===== Stack Trace =====\r\n"
                        + "{2}"
                        + "=== End of Stack Trace ===\r\n",
                        ++count,
                        assert.exception.Message,
                        assert.stackTraceString
                        );
                }
                assertFailErrors.Clear();
            }
            return message;
        }

        /// <summary>
        /// Process the errors in error list.
        /// </summary>
        public void Process()
        {
            lock (processLock)
            {
                if (mainThread == Thread.CurrentThread && errors.Count > 0 && !shouldThrowAssertFailException)
                {
                    // Create an exception object which is of the same type as the exception created by checkers,
                    // and append the stack trace string to the error message.
                    Type type = errors[0].exception.GetType();
                    string message = GenerateBypassedErrorMessage();
                    object exception = Activator.CreateInstance(type, message);

                    // Error list must be cleaned here. 
                    errors.Clear();
                    throw (Exception)exception;
                }
            }
        }

        /// <summary>
        /// Adds the exception reported by checkers to the error list and terminates the current thread if current thread is not main thread. 
        /// </summary>
        /// <param name="checkerException">The exception generated by checkers.</param>
        public void ReportAsyncException(Exception checkerException)
        {
            // Indicating the number of frames which should be skipped in the call stack when generating stack trace string.
            const int skippedFrames = 4;

            lock (reportAsyncExceptionLock)
            {
                if (this.assertFailuresBeforeThrowException <= assertFailErrors.Count ||
                    checkerException.GetType() != typeof(AssertFailedException))
                {
                    errors.Add(new ErrorDescriptor(checkerException, GetStackTraceString(skippedFrames)));
                }
                else
                {
                    if (errors.Count == 0 && !shouldThrowAssertFailException)
                    {
                        //assert fail is before the exception, thould throw assert fail exception.
                        shouldThrowAssertFailException = true;
                    }
                    assertFailErrors.Add(new ErrorDescriptor(checkerException, GetStackTraceString(skippedFrames)));
                }

                Process();

                if (errors.Count > 0 &&
                    Thread.CurrentThread != mainThread)
                {
                    Thread.CurrentThread.Abort();
                }
            }
        }

        /// <summary>
        /// Generates the stack trace string
        /// </summary>
        /// <param name="skippedFrames">The number of call stack frames which should be skipped when generating stack trace string.</param>
        /// <returns>The stack trace string.</returns>
        private static string GetStackTraceString(int skippedFrames)
        {
            StackTrace st = new StackTrace(skippedFrames, true);
            if (st.FrameCount <= 0)
            {
                return string.Empty;
            }

            StringBuilder sbStacks = new StringBuilder();
            Assembly callingAss = st.GetFrame(0).GetMethod().Module.Assembly;
            for (int i = 0; i < st.FrameCount; i++)
            {
                Assembly assembly = st.GetFrame(i).GetMethod().Module.Assembly;
                if (assembly != callingAss)
                {
                    break;
                }
                sbStacks.Append(new StackTrace(st.GetFrame(i)).ToString());
            }

            if (sbStacks.Length > 0)
            {
                return sbStacks.ToString();
            }

            return string.Empty;
        }
    }
}
